# Cogo 概览

Cogo 可以说是一种开发理念，是一种用最少的代码完成 Web 交互功能的一种思想，Cogo 的最终目标是开发出一个能实现“积木式编程”的工具或模型。**Cogo** 中的`Co`表示`Component`，`go`取自`Lego`的`go`，表示“组件积木”的意思，同时也是为了致敬派珀特发明的 **LOGO** 编程语言（Scratch 的灵感来源）。期望通过一种搭建积木的手段来构建 Web 应用，而且积木的“形状”可以自定义，就像沙盒游戏一样，创造自己的世界。但是在现有条件下，用积木的方式构建应用，完全不写任何代码，还是一个几乎不可有的任务。于是先退而求次，可以先实现“尽可能少写代码”。

Cogo 正在开发中，也许用不了多久，第一版就会面世。

## Web开发演进

2000年以前，网页制作工具非常流行，记得当时有 Microsoft FrontPage（1997）、Micromedia Dreamweaver（1997） 和 Adobe GoLive，它们“所见即所得”的编辑方式非常友好，不会写 HTML 和 CSS 也能创建网站，个人网站也像现在的个人公众号一样普通。Dreamweaver 后来还有专门的认证。但这些工具主要适用于中低端开发人员，想实现更多的功能，还得自己写代码。

在那时动态网页语言也非常丰富，Asp、Jsp、Php 都有，这些语言在编写时嵌入到 HTML 中，可以实现很多复杂的功能。优点是开发效率很高，缺点是不同的代码互相交织在一起，维护困难。那时也没有交互的概念，一般通过表单向服务器端提交数据。

2001年，Asp.Net 1.0 诞生，有了 WebForm，也有了服务器端组件和服务器端事件，事件由 C# 编写并编译，每次服务器端事件都提交一次表单，页面会发生刷新，用户体验很不理想。但是 Asp.Net 的分层思想还是惊艳的，客户端代码和服务器端代码分离，提高了可维护性。

2002年，Spring MVC 诞生，提出了 MVC 三层模型，把 Web 开发分成了模型、控制器和视图三层，后来又加入了数据层，做到了各层之间互相不干扰，大大提高了可维护性。缺点就是要编写更多的代码。2009年，Asp.net MVC 1.0 发布，我记得当时开发应用时不断的再写 Pojo 类，不断的再打开连接、操作数据库、关闭连接。后来使用了数据访问层框架，虽然一定程序上提高了开发效率，但是同时也降低了灵活性。

2006年，Ajax 大行其道，Web 2.0的概念也提了出来，Web 应用更注重交互。

2009年，Angular 发布。2013年，React 开源。2014年，Vue 正式发布。三大前端框架使前后端开发人员各司其职，分工更明确，也出现了专职的前端工程师。2014年，Spring Boot 也面世了，微服务的概念也被提了出来。更加速了前后端的分离和分工。后端只管提供接口，前端负责所有交互操作。前后端分离的开发和部署模式，让技术人员可以更精确的控制每一个节点的负载，以期提供最大化用户并发支持。

2012年，Adobe Muse 正式版发布，从 Dreamweaver 的 更注重页面而转向更注重交互，让那些不懂代码的设计师也能创建交互网页。

2016年，Scratch 语言风迷全球，让孩子也可以像搭积木一样完全动画和游戏的制作。同时，Google 的 Blockly 可视化编程语言发布。遗憾的是这两家主要用过教育领域。

不过已经有人尝试在 Web 端构建类似积木方式的编程方式，我的一个前同事是一个技术高手，一直在做相应的努力。国内有一个应用 CoolSite360 也可以在线创建交互式网站。

今天，很多软件或语言已经消失不见，前后分离的开发模式和微服务正在盛行，基本成了行业标准，但 php 这门“世界上最伟大的语言”依然活得非常滋润，而且 Asp.Net 在国外依然流行。存在即合理！


## Cogo 想法的由来

2009 年以来，因为一直从事数据相关的工作，与 Web 开发相隔甚远。在 2017 年学习 Spring Boot 前，一度非常恐惧 Asp.net MVC 的开发模式，编写大量的重复代码，复制粘贴修改再复制粘贴修改。没想到，Spring Boot 比 Asp.net MVC 更变本加厉，为了做一个接口，需要修改`6`个文件！哪怕一个简单的只有一个 SELECT 语句的查询接口，也要修改 Pojo 类、MyBatis 查询、Mapper 映射、Service 方法、Controller 及逻辑，还可能需要 Enum 枚举类。冗长的开发过程大大降低了开发效率，如果不能接受这种模式，那么只能尝试改变。

2017 年，为了提速部门的数据开发工作，减少大量重复代码的编写，我开发出了 DataHub 多数据源框架。应用于部门数据开发的同时，也引入到了 Spring Boot 项目中。就这样，MyBatis 被干掉了，可以在 Controller 编写数据处理逻辑，也不需要再也 Pojo 类了。 

即使这样，后端接口开发依然要写不少的冗余代码，比如要建立相应的 Controller，声明 DataHub 对象，通过 SQL 操作数据，关闭 DataHub 对象。2018 年，当部门要做一 Web 项目时发现部门内根本没有 Java 开发人员！于是花了两天时间，开发了 [ApiInOne 工具](/oneapi/overview.md)并提供了编辑页面，开发接口只需要写 SQL 即可。再后来，参照 Oracle 的 PL/SQL，不断增加了判断、循环等处理逻辑，以让 ApiInOne 支持更广泛，已经可以解决 95% 以上的接口开发需求。

2019 年，为了解决大部分数据开发人员不会写 Python 或 Java 的问题，在 DataHub 基础中，开发出了 [PQL 中间件语句](/pql/overview.md)，进一步简化了数据处理过程的编写。PQL 比 ApiInOne 中的 SQL 功能更强大，于是把 PQL 应用到了 ApiInOne 中。至此，虽然依然在 Spring Boot 环境中，但编写接口已经不再需要编写 Java 代码，只需要一条或多条 SQL 语句即可，即几乎去掉了所有 SQL 之外的代码。

因为不会 Vue，所以自己的 Web 项目并没有使用前后分离的模式开发，不过还是做到了页面和后端逻辑分离。新的问题又来了，当页面第一次加载时，前端页面需要展示数据，这些数据需要提前在 Controller 中取出来，然后通过 model 对象传递给页面，页面上使用 FreeMarker 或 ThymeLeaf 模板引擎进行展示。是的，依然需要在页面对应的 Controller 中写逻辑，同时需要写类和相应的方法。如果要向前端传递的数据比较多，那么 Controller 中的逻辑会非常复杂，还要记住非常多的 FreeMarker 或 ThymeLeaf 语法，麻烦呀。因为非常怀念 Asp 的开发方式，所以自己基于 PQL 开发了一个[模板引擎 Voyager](/voyager/overview.md)，这样可以像写 Asp 或 php 一样在页面上写服务器端代码了，但是比 Asp 写的代码更少。就这样，我干掉了 FreeMarker。

编写页面回到了 Asp 时代，但是因为系统中大量交互的存在，仍需要编写非常多的事件和前端逻辑，也需要写非常多的 Html 和 CSS。经常因为做的页面功能和样式差不多，也经常要复制粘贴修改。终于，在开发一个新模块时，一个新的页面和另一个模块的某个页面基本相同，复制过来代码后，还没有修改，我忍不住停了下来，开始思考新的解决方法。

我想干掉 Html，也想干掉 CSS，更想干掉 Javascript。让页面制作更简单，能不能像累积木或者玩《我的世界》游戏那样编写 Web 应用？

## Cogo 实现

能否在 Vue 或 React 实现 Cogo 思想

## Cogo 基础

是否可以在特定的领域实现积木编程，比如管理信息系统。
负载均衡

### 精简思路

减少组件的属性，扩展已有的组件属性，同一属性实现更多的功能
```
<input id="Age" type="int" required="Please input your age." />
```

以上例说明，`input`尽可能不填写其他属性，使用系统默认值。`type`的属性值`int`本来没有，即在原有的基础上进了扩展。`requrired`属性包含两个功能，一是这个输入框的信息必填，另一个如果输入框为空则提示`Please input your age.`。

### 运行环境

由于需要与数据库或其他数据源进行交互，因此编写 SQL 语句是少不了的，即使能做到像 Hibernate 或其他数据层框架那样自动映射，也完全避免不了其他的后端逻辑。PQL 可以完成所有后端逻辑，缺什么加什么就好。

由于 PQL 需要运行在 JVM 虚拟机上，所以把在国内非常流行 Spring Boot 作为 Cogo 的运行环境。

### 开发重点

要想让 Cogo 工作，要做的有三件事：第一个是“内容”，是 Cogo 的关键，内容包含页面和系统；第二个是 Cogo 开发环境，用来生产内容；最后一个是运行 Cogo 内容的环境。比如 Dreamweaver 生产 html 网页，浏览器运行 html。当然，这两个环境也可以是同一个，比如 Excel。

因为暂时不需要“所见即所得”的开发环境，所以内容和运行环境就成了开发重点，开发环境暂时使用 Visual Studio Code 等工具代替。

### Cogo 样式

CSS 可以控制页面和元素的样式，但是为了尽可能的不写样式代码，可以使用主题来代替样式控制（CSS），即预选设定好的样式。主题可以预选创建多套，每套主题一套样式风格，Qross 系统已经可以实现 32 种颜色风格的随机切换，可以套用过来。

### Cogo 组件

“组件”是积木编程的基本单位，组件是一个或多个元素（或标签）的集合，并且有自己的样式、属性、方法和事件。例如：

```html
<input type="text" id="TextBox1" />
<button id="Button1" onclick="$s('#TextBox1').focus()"></button>
```

以上代码中，`input`或`button`是元素标签名，`focus`是方法，`onclick`是事件。在 Cogo 中，因为方法只能通过编程的方式调用，所以要尽可能的消除方法。

丰富的组件是实现积木编程方式的前提，并且组件要提供交互功能，以满足系统要求。而且，系统内置组件不可能满足所有需求，用户可以自定义组件。以下是一些可以自定义或扩展 Html 标签的经验：

* 可以定义自己的 HTML 标签，如 `<clock></clock>`。浏览器不会解析这些自定义的标签，需要自己编写解析逻辑。自定义标签可以自已添加属性、方法和事件。对于自定义标签，浏览器但也不会显示出来。
* 对于浏览器支持的标签，可以添加自定义属性，这个属性不会被浏览器解析和处理，需要自行处理，也可以作为额外保存数据的手段。例如：`<input focus-value="Hello World" />`。通过标签的`setAttribute`和`getAttribute`方法可以设置或获取自定义属性。
* 对于浏览器支持的标签属性，可以自定义属性值，如`<input type="int" />`，但是这个值也需要自行处理。
* 浏览器支持的标签不可以添加自定义方法和自定义事件， 一般情况下不需要。

页面与用户交互最主要的是依靠组件的事件，一般情况下触发事件通过 Ajax 调取后端接口，接口中实现后端逻辑。例如：
```html
<button id="Button1"> Submit </button>
<script type="text/javascript">
$s('#Button').onclick = function() {
    $POST('/api/test?id=$(id)&name=${name}')
        .success(data => {
            window.location.href = '/page1';
        });
}
</script>
```

为了达到尽可能少写代码的目的，需要把以上代码进行缩减，可以这样：

```html
<button onclick="/api/test?id=$(id)&name={name}" jump-to="/page1"> Sumbit </button>
```

*上面要调取的接口可以跨域。

再简化些，甚至可以干掉后端接口：

```html
<button onclick="update table1 set name=#{name} where id=#{id}" jump-to="/page1"> Sumbit </button>
```

对于页面初始化时，也可以通过接口或 PQL 语句初始化数据，例如：
```html
<select data="select name, id from table1"></select>

<table data="select * from table2 -> first row"></table>
```

可以说，缩短获取数据或交互流程是减少代码量的关键点。


### Cogo 页面

为了最大化减少代码和复杂性，需要把所有的逻辑尽可能的放在一个页面上来，尽可能减少分层或者分页面。

* 使用 MarkDown 作为 Cogo 页面的源代码。MarkDown 是一种语法非常简单的文档格式，编写内容极其方便。MarkDown 可以无障碍转化成 HTML，且在编辑时支持与 HTML 代码混合。
* Voyager 模板引擎可以通过嵌入式 PQL 在页面上编写服务器端代码。需要升级 Voyager 模板引擎以支持 MarkDown 文档的转换。不过尽量减少交叉编写客户端和服务器端代码。



基于以上两个条件，所有只剩下两个关键逻辑还未实现，一是初始化页面组件时尽量不使用服务器端代码以保证逻辑清楚，二是交互事件尽可能简单，以避免写 Javascript 代码。

### Cogo 系统
一个页面包含所有交互逻辑，多个页面构成应用

标准登录，LDAP，SSO
企业微信插件、钉钉插件、小程序
用户系统


框架布局也可以使用主题控制
组件上加载数据可以直接执行 PQL，可以直接调取接口（含跨域接口）
客户端事件可以直接执行 PQL，可以直接调取接口（含跨域接口）

独立的编辑平台，前期可以只提供代码编辑，以后慢慢制作图形化界面
发布后的系统在修改Bug或增加功能时无需重启
创建的系统由一个 Spring Boot 解析项目构成，创建的页面保存在项目之外，通过项目配置加载
支持国际化，由 Voyager 提供支持
更新无需要重启系统，页面即配置，自由修改
修改器可以连接不同系统

## 适用场景
可适用于文档管理等场景

