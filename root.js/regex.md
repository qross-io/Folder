# 正则表达式

正则表达式是查找匹配字符中的强大手段，正则表达式对于处理字符串的重要性甚至可以理解为 SQL 语句对操作数据库的重要性。而且，正则表达式是行业标准，适用于任何语言，不仅 root.js 库，整个 Qross 系统中大量应用了正则表达式，比如 PQL 用来解析 SQL 语句。这里仅介绍 Javascript 中使用正则表达式的方法和基础知识。

```javascript
let s = 'Hello World';
//查找目标字符中是否存在 h 和 l 字母，并忽略大小写
if (/[hl]/i.test(s)) {
    console.log('Found.');
}
```

上例中，`/[hl]/i`部分即为正则表达式，使用正则表达式的方法来对字符串进行匹配和其他操作。

## 正则表达式类

一般使用`/`包围的方式来声明正则表达式，`[hl]`表示只匹配`h`和`l`两个字母，`i`是一个 flag，表示忽略大上写。再举个例子。

```javascript
let s = 'Hello World, today is 2021-4-29.';
let x = s.replace(/\d/g, '');
```

上例中将字符中的所有数字替换掉，其中`\d`表示匹配数字，`g`表示查找所有匹配。

```javascript
let r = new RegExp('\\d', 'g');
```

主要方法：

* `regex.test(str)` 检查正则表达式是否与字符串匹配。
* `regex.exec(str)` 查找匹配，返回一个数组对象，包含每一次匹配和其他信息。可不断的执行直到`null`为止。
    + 数组索引包含匹配后的分组信息：`0` 表示`group(0)`，`1`表示`group(1)`。    
    + `index` 表示匹配在字符串中的位置，索引从 0 开始。
    + `input` 表示输入的字符串。
* `string.match(regex)` 如果`regex`的 flag 不含`g`，作用与上一个方法相同，如果 flag 包含 `g`，那么返回包含所有匹配的数组。
* `string.replace(regex, strToReplace)` 字符串的替换方法，第一个参数可以使用正则表达式，flag 不包含`g`则只替换第一项，包含`g`则替换全部匹配。
* `string.search(regex)` 查找匹配结果字符串在指定字符串中的位置。
* `string.split(regex)` 按指定的正则表达式分隔字符串。

非 flag 属性如下：

* `source` 正则表达式的字符串表示。
* `lastIndex` global 模式下会返回每一次匹配的开始位置。

## flag 列表

Flag 可以理解为正则表达式类的选项，可以直接在声明时指定，也可以在正则表达式对象上通过属性设置。下面 4 条语句等效。

* `let x = /[a-z]/ig;`
* `let x = new RegExp('[a-z]', 'ig');`
* `let x = /[a-z]/; x.ignoreCase = true; x.global = true;`
* `let x = new RegExp('[a-z]'); x.ignoreCase = true; x.global = true;`

所有 flag 的功能如下：

* `i` 对应属性`ignoreCase`，忽略大小写
* `g` 对应属性`global`，查找字符串的所有匹配。
* `m` 对应属性`multiline`，匹配多行。这个参数的使用比较苛刻，主要用于配合开始符号`^`和结束符号`$`使用。要求待匹配字符串中必须有换行符`\n`，且正则表达式中有开始符号`^`或结束符号`$`，则`m`修饰符才有意义。不使用`m`时，`^`匹配第一行的开始，`$`匹配每一行的结束，使用`m`时，`^`匹配整个字符串的开始，`$`匹配整个字符串的结束。
* `y` 对应属性`sticky`，可以理解为默认添加开始符号`^`，通过正则表达式的`lastIndex`属性可以设置开始匹配位置。ES 6 新增。
* `s` 对应属性`dotAll`，符号`.`默认匹配一行内所有字符，即不匹配回车符号`\r`和`\n`，使用`s`会改变这种情况，即`.`符号匹配所有字符。ES 9 新增，在这之前使用`[\s\S]`匹配任何字符。
* `u` 对应属性`unicode`，匹配 Unicode 字符。`\uxxxx` 查找以十六进制数`xxxx`规定的 Unicode 字符。

flag 可以混合使用。在 Java 和 Scala 中，flag 写在正则表达式中最前面位置，如`(?i)` 不区分大小写，Javascript 不支持这样写。

## 常用字符表

常用符号

* `.` 匹配任意单个字符，行结束符除外。
* `\d` 匹配任意阿拉伯数字，相当于`[0-9]`。
* `\D` 匹配任意一个不是阿拉伯数字的字符，相当于`[^\d]`, 这里`^`用在`[]`中表示取反的意思。
* `\w` 匹配任意阿拉伯字母，数字和下划线, 相当于`[0-9a-zA-Z_]`，变量中用到的符号。
* `\W` 与`\w`相反， 相当于`[^0-9a-zA-Z_]`。
* `\s` 匹配一个空白符，包括空格符，制表符，换行符，换页符和其他空格字符。
* `\S` 匹配一个非空白符，与上面相反。

空白字符的表示方法

* `\t` 匹配一个水平制表符
* `\r` 匹配一个回车符
* `\n` 匹配一个换行符
* `\v` 匹配一个垂直制表符

字符集合

* `[abc]` 字符组，表示匹配集合中的任意一个字符，可以用`-`来指定范围。例如`[0-9]`表示所有数字，`[a-z]`表示所有英文字母。
* `[^abc]` 反义字符组，匹配不是集合中字符的一个字符，可以用`-`来指定范围。例如`[^\d]`表示所有不含数字。

匹配组或分组

* `( )` 匹配组在匹配到结果时可以直接通过索引得到相应的结果，如`let x = /([a-z])o/.exec('hello world');`，`x[0]`返回`lo`，`x[1]`返回字母`l`。
* `|` 表示“或”，如`/(hello|hi) world/`匹配`hello`或`hi`都可以。

边界

* `^` 不在`[]`中时，匹配字符串每行的开始。
* `$` 匹配字符串每行的结束。
* `\b` 匹配零宽单词边界，如`/[a-z]+\b/`匹配`"Hello World"`，得到`Hello`。
* `\B` 匹配非零宽单词边界，如`/[a-z]+\B/`匹配`"Hello World"`，得到`Hell`。

重复

* `?` 匹配 0 次或 1 次，表示有或者没有。
* `+` 重复至少一次或多次。
* `*` 重复 0 次或多次。
* `{n}` 重复 n 次。
* `{m,n}` 重复最少 m 次，最多 n 次。
* `{m,}` 重复最少 m 次。

非贪婪模式

* `?` 在重复符号后面加上问号`?`表示非贪婪匹配，如`\d+?`。

## 反向引用

使用符号`$n`可以得到最近一次匹配的内容，可使用`$0`到`$9`，表示匹配结果中各分组的值。

```javascript
'04/29/2021'.replace(/(\d{2})\/(\d{2})\/(\d{4})/, '$3-$1-$2')  //返回 2021-04-29
'border-left-color'.replace(/-([a-z])/g, (m, n) => n.toUpperCase()); //返回 borderLeftColor
'borderLeftColor'.replace(/[A-Z]/g, l => '-' + l.toLowerCase()); //返回 border-left-color
```

## 断言

断言用于查找匹配的前面的前面或后面是或者不是指定的字符或匹配，非常有用。“零宽”表示指定的匹配不返回；“正向”表“肯定”、“是”，“负向”表“否定”、“否”；“先行”指从左向右查找匹配，也可以理解是指定要匹配结果右侧的字符，“后行”是要匹配结果左侧是或者不是指定的字符。

* `(?=pattern)` 零宽正向先行断言，设定指定匹配后面有哪些字符。
* `(?!pattern)` 零宽负向先行断言，设定指定匹配后面没有哪些字符。
* `(?<=pattern)` 零宽正向后行断言，设定指定匹配前面有哪些字符。ES 9 支持。
* `(?<!pattern)` 零宽负向后行断言，设定指定匹配前面没有哪些字符。ES 9 支持。
* `(?:pattern)` 非捕获组，表示匹配但不在结果中返回。

## 命名捕获组

ES 9 支持对分组进行命名，使用`?<name>`，写在分组内。

```javascript
let x = /(?<month>\d{2})\/(?<day>\d{2})\/(?<year>\d{4})/.exec('04/29/2021');
let y = x.groups.year + '-' + x.groups.month + '-' + x.groups.day;
```

当分组多时很有用。

	